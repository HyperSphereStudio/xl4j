/*
 * COM Java wrapper 
 *
 * Copyright 2014 by Andrew Ian William Griffin <griffin@beerdragon.co.uk>.
 * Released under the GNU General Public License.
 */
package uk.co.beerdragon.comjvm.stub;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Class loader for bringing generated stubs into scope. The {@code byte[]} data for a generated
 * stub can be passed to this class loader and the class name then resolved.
 */
/* package */class ByteCodeClassLoader extends ClassLoader {

  /**
   * Marker thread identifier used in {@link #_byteCode} to indicate that a map object is considered
   * dead by a consuming thread and so the producing thread may need to generate a new instance.
   */
  private static final Long INVALID_THREAD_ID = -1L;

  /**
   * Generated class byte code, held as a (class name, (thread identifier, byte code)) map.
   * <p>
   * This handles the edge cases of two threads generating stubs simultaneously without excessive
   * locking of the class loader.
   */
  private final ConcurrentMap<String, Map<Long, byte[]>> _byteCode = new ConcurrentHashMap<String, Map<Long, byte[]>> ();

  /**
   * Creates a new instance.
   * 
   * @param parent
   *          the parent class loader, not {@code null}
   */
  public ByteCodeClassLoader (final ClassLoader parent) {
    super (parent);
  }

  /**
   * Stores a generated class in the loader so that the calling thread may then resolve it.
   * <p>
   * This class loader will retain a reference to the passed array; the caller must not use this
   * array for anything else after calling this method.
   * 
   * @param name
   *          class name to store, not {@code null}
   * @param byteCode
   *          byte code content of the class, not {@code null}
   */
  /* package */void register (final String name, final byte[] byteCode) {
    final Long threadId = Thread.currentThread ().getId ();
    do {
      // Get any posting for this class from other threads
      Map<Long, byte[]> defs = _byteCode.get (name);
      if (defs == null) {
        // No other threads have stored byte code, so this thread can try
        defs = new HashMap<Long, byte[]> ();
        defs.put (threadId, byteCode);
        defs = _byteCode.putIfAbsent (name, defs);
        if (defs == null) {
          // Byte code is now stored
          return;
        }
        // Another thread has stored byte code for this class
      }
      synchronized (defs) {
        if (!defs.containsKey (INVALID_THREAD_ID)) {
          // Map is valid so this thread can store its byte code
          defs.put (threadId, byteCode);
          return;
        }
        // This map is not valid so repeat the process
      }
    } while (true);
  }

  /**
   * Removes a buffer of generated bytecode for the associated class name previously passed to
   * {@link #register} by the calling thread.
   * 
   * @param name
   *          the class name, not {@code null}
   * @return the bytecode, or {@code null} if there was none
   */
  private byte[] consume (final String name) {
    final Map<Long, byte[]> defs = _byteCode.get (name);
    if (defs == null) return null;
    synchronized (defs) {
      // Consume any byte code previously posted by this thread
      final byte[] byteCode = defs.remove (Thread.currentThread ().getId ());
      if (defs.isEmpty ()) {
        // This was the last use of this map; mark it as invalid
        defs.put (INVALID_THREAD_ID, byteCode);
        _byteCode.remove (name);
      }
      return byteCode;
    }
  }

  /**
   * Converts a block of generated byte code to a {@link Class} instance.
   * 
   * @param name
   *          the name of the class, must match the name encoded in the byte code, not {@code null}
   * @param byteCode
   *          the generated byte code, not {@code null}
   * @return the resolved class, never {@code null}
   */
  public Class<?> load (final String name, final byte[] byteCode) {
    register (name, byteCode);
    final Class<?> clazz = loadClass (name);
    consume (name);
    return clazz;
  }

  // ClassLoader

  @Override
  protected Class<?> findClass (final String name) throws ClassNotFoundException {
    final byte[] byteCode = consume (name);
    if (byteCode != null) {
      return defineClass (name, byteCode, 0, byteCode.length);
    } else {
      throw new ClassNotFoundException (name);
    }
  }

  @Override
  public Class<?> loadClass (final String name) {
    try {
      return super.loadClass (name);
    } catch (final ClassNotFoundException e) {
      throw new IllegalArgumentException (name, e);
    }
  }

}
